# 数据结构与算法

## 什么是数据结构？

要理解数据结构，首先从目的、功能的角度看。计算机要解决一个具体的问题，大致需要经过如下几个步骤：

1. 分析问题，确定数据模型
2. 设计相应的算法
3. 编写程序，运行并调试，直至得到正确的结果

这里提出了一个概念叫做 **数据模型** 。作为一个数学系应用数学专业的学生，我一个想到的是既然都叫做模型，那么数据模型和数学模型有什么异同呢？

首先一个最令人困惑的问题是数学、数据，这两个词到底有什么区别？（我最近比较喜欢用这种分析语义语词的方式理解问题）。参考百度上的解释：

- **数学** 作为学科，其目的在于研究数量、结构、变化、空间以及信息等概念。作为思维方法，是人类对事物的抽象结构与模式进行严格描述的一种通用手段。
- *与其说是通用手段，不如说每每当人类将问题给抽象化，特征化，便无可避免地使用（亦或是发明）某种“数学”*。
- **数据** 作为类，是指对客观事件进行记录并可以鉴别的符号，是对客观事物的逻辑归纳。数据经过加工和处理成为可被解读的信息。

至此，我觉得可以给出一个更加清晰的定义：数学是对世界的抽象化，而数据是对世界的符号化。数学抽象的结果最终表现一整套的数学理论（由公理，命题和论证组成），而数据符号化的结构最终表现为符号以及符号之间关系构成的集合与现实世界的对应关系（如计算机中的二进制mp3文件和播放出来的声音之间的关系）。

在这本数据结构的教材中，数据的定义更加切实，作者非常直接了当地指出：“**数据是描述客观事物的数和字符组成的集合**，是所有能够被输入到计算机中，且能够被计算机处理的符号的集合”。

从数据作为集合的概念延展开来，我们不难理解数据集合中的元素称为 **数据项**，数据集合的子集称为 **数据对象**，数据集合上的关系称为 **数据结构** 。

其中，数据项是保持数据所代表含义的独立性的最小单位，例如一名学生的学号为20192025xxx，不能再进一步拆分处理，否则便会丧失其具体的含义。

数据对象是保持性质相同的数据元素共同构成的集合。所谓“性质”，一般指的是这个集合中的每个元素对应地描述了一类性质相同对象，而非是在说数据元素本身有什么性质。例如ASCII编码构成的数据对象共同描述了计算机可以表示的符号和形状。

数据结构是数据集合上的关系。这样的关系往往是人们通过分析现实问题认为建构出来的，与数据本身取值多少可能没有必然联系。

最后一点，是数据结构的层次问题。通常来讲，数据结构包含着两方面的层次，分别是逻辑结构和存储结构，以刻画数据含义之间的逻辑关系（与具体的问题有关）和数据在计算机电子构件中的存储表示及其关系。任何对数据结构的改动，从某种意义上讲，都可以被称之为数据的 **运算**，由于数据结构的不同层次，运算既可以是更改数据在计算机中的存储关系的各种操作，也可以是对现实事物之间关系的刻画。

### 逻辑结构及其表示

在现实世界中数据元素之间关系是多种多样的，但在数据结构中主要讨论数据之间的相邻关系或者邻接关系。

#### 逻辑结构的分类

按类型划分，我们对数据的逻辑结构作归纳，无外乎如下几类：

1.**集合**
: 集合是指数据元素之间除了属于同一个集合的关系之外，再没有其他关系的集合。

2.**线性结构**
: 线性结构(linear structure)是指该结构中的数据元素之间存在一对一的关系。其特点是除了唯二两个起点和终点仅有一个唯一的前驱（或后继）以外，其余的每一个数据元素均各有一个前驱元素和后继元素。

3.**树形结构**
: 树形结构是指该结构中的数据元素存在一对多的关系，除了为唯一一个顶点没有前驱元素，以及树叶节点没有后继元素外，其余每一d个数据元素均有一个前驱元素以及至少一个后继元素。

4.**图形结构** 
: 图形结构是指该结构中数据元素之间存在多对多的关系，每个数据元素的前驱和后继的个数可以使任意的。

#### 逻辑结构的表示

（1） 图表表示
: 图表表示就是直接按顺序编号，把数据项在一张表格中列出来。例如：

| 学号 | 姓名 | 性别 |
|:----:|:----:|:----:|
|   1  | 张斌 |  男  |
|   8  | 刘丽 |  女  |
|  34  | 李英 |  女  |
|  20  | 陈华 |  男  |

（2） 集合（二元组）表示
: 我们称一个元素集合和一个关系二元关系集合构成一个逻辑结构的二元组，一个二元组的表示如下：

$B=(D,R)$

其中，$D$ 为数据项构成的集合，$R$ 为$D$ 上的二元关系集合。

$D=\{d_i | 1 \le i \le n, n \ge 0 \}$ 

$R = \{r_j | 1 \le j \le m, m \ge 0 \}$ 

$d_i$ 表示集合 $D$ 中的第 i 个元素，$n$ 为$D$ 中元素的个数。$r_i$ 表示集合 $D$ 中的第i种关系，$m$ 为$R$ 中的关系个数。对于关系集合$r_i$ 来说，集合中的每一个元素为 $<x,y>, x,y \in D$ 代表元素x
与元素y之间存在相邻关系（<前驱，后继>）。

（3）图形表示
: 简单地用一个圆圈+数字来表示节点，用箭头来表示相邻关系。可以做出如下的图形

![20211003](https://picofwwzy-1307689287.cos.ap-shanghai.myqcloud.com/uPic/20211003.png)

其二元组表示为：
$$
\begin{aligned}
& B = \{ 25, 36, 48, 57, 64, 82, 75 \} \\ 
& D = \{ r_1, r_2 \} \\
& r_1 = \{ <48,25>, <25,36>, <48,64>, <64,57>, <64,82>, <82,75> \}\\
& r_2 = \{ <25,36>, <36,48>, <48,57>, <57,64>, <64,75>, <74,82> \} 
\end{aligned}
$$
### 存储结构

在实际应用中，数据结构的存储方法是灵活多样的，归纳起来，数据结构中有以下4中常用的存储结构类型。

#### 顺序存储结构

顺序存储结构（sequential storage structure）是采用一组连续的存储单元存放所有的数据元素。数据元素不仅在逻辑结构中相邻，由于顺序存储的方式，其在存储其中的存储位置也相邻。

*优点*：存储效率高，可以实现对元素的随机存取。

*缺点*：不便于数据修改，对元素的插入和删除操作可能需要移动一系列的元素。

#### 链式存储结构

在链式存储结构（linked storge structure）中，每个逻辑元素单独分配一个内存节点，所有节点的内存地址是间断的，通过每个节点的附加指针连接起来，最终将所有的逻辑元素链接起来。

*优点* ：方便数据修改（只需要修改前后节点的指针）。

*缺点* ：不能对存储节点进行随机存取，存储效率相比顺序存储减半。

#### 索引存储结构

索引存储结构（indexed storge structure）是指在存储元素信息的同时还建立附加的索引表。索引表中每一项称为索引项，其一般形式为“关键字，地址”，关键词用于标识某个特定元素，地址用于记录该元素的内存地址。通常为了便于查询，索引表中所有索引项是按关键字有序排列的。

*优点* ：查找效率高

*缺点* ：建立了索引表，增加了空间开销

#### 哈系（或散列）存储结构

哈系存储结构（hashed storge structure）的基本思想是根据元素的关键字通过哈系函数直接计算出一个值，并将这个值作为该元素的存储地址。

*优点* ：查找速度快，能够对元素进行快速的查找和插入

*缺点* ：只存储元素的数据，不存储元素之间的逻辑关系（没有简便的方法以任何一种顺序遍历表中的数据项)；基于数组的哈系表，不便于扩展，在数组基本被填满后性能下降得非常严重

### 数据运算

数据运算是指对数据实施的操作。每种数据结构都有一组相应的运算，最常用的运算有检索、插入、删除、更新和排序等。数据运算最终需要在对应的存储结构上以特定的算法实现。

值得注意的一点是，运算的定义是基于逻辑结构层面，出于人们对解决现实问题的需要抽象出来的特定功能或者方法。运算的实现是基于存储结构层面，是依靠算法对具体的存储单元进行编程操作实现的。

运算之所有被分为这两种层面，我想，一方面虽然按书上说的“体现了软件工程的思想”，另一方面也导致了程序用户和程序员之间的分裂，使得一般的用户无法接触到程序内部的细节，只能被动地使用程序定义好的功能，而不能主动地凭自己的意见作修改。如果有那么一天，现实计算机的存储方式能够更加适合人类看待问题的方式，在迎合逻辑结构的同时，不再需要结构复杂的算法（才能保证稳定和效率）就能解决所有的问题，那么这里运算的两种层次的分裂将为被弥合。我想，届时人类可以利用计算机做到更多有趣的事情？

### 数据类型和抽象数据类型

这一部分还是自己在实践中掌握比较好

## 算法及其描述

### 什么是算法？

算法（algorithm）是对特定问题求解步骤的一种描述，它是指令有限的序列。其中每条指令代表计算机的一个或者多个操作。

一个算法应该具有一下5中重要的特性：

1. 有穷性：一个算法必须在有限步骤内完成。
2. 确定性：对于每种情况执行的操作的都是确定的，即使说相同的输入总应该有同样的输出。
3. 可行性：算法可以通过计算机基本操作的有限次组合来完成，否则计算机无法实现。
4. 有输入：作为算法加工对象的量值，通常体现为一组变量，这是不可或缺的（可能程序员可以不要求任何变量的输入，但一个算法总是有特定加工处理的对象，比如void函数体内部的变量）。
5. 有输出：作为算法对信息进行处理加工后的结构，一个算法有一个或者多个输出。

*算法输入和输出的特定关系构成了算法的功能*.

### 算法设计的目标

1. 正确性：算法能够正确地执行预先设定的功能和性能要求。这是最最基本的要求。
2. 可实用性：要求程序能够方便地被使用，也称为用户友好性。
3. 可读性：算法应该易于理解，这要求的算法的逻辑必须是清晰的、简单的和结构化的。
4. 健壮性：要求算法具有较好的容错性，即提供异常处理。
5. 高性能和低存储需求：要求尽可能节省算法时间和空间的开销。

### 算法描述

简单介绍一下应该是有5种方法，可以用来描述一个确定的算法：

1. 自然语言：可以直接以通俗形象的语言来描述算法，尽管会丧失一定的严谨准确性。
2. 流程图：适合顺序、循环结构的算法，不具有递归结构的算法
3. 伪代码：结合自然语言和程序语言，比较容易理解。
4. 程序语言：最直接的描述方法
5. 调用流程：以程序中函数为单位来描述算法的方法，适合一些复杂工程，也可以用来分析递归算法的成效。

## 算法分析

### 什么是算法分析？

算法分析就是分析算法占用计算机资源的多少。而计算机资源主要是CPU时间和内存空间，因此算法分析又分为时间性能分析和空间性能分析。

### 算法时间性能分析

一般来说，有两种衡量算法时间性能的方法，即事后统计法和事前估计法。（按字面意思就很好理解）

而在设计算法的过程最常用的是事前估计的方法，一般我们称之为算法的时间复杂度分析。

算法的时间复杂度分析一般分为两步（熟练的Oier大概可以直接看出来，不过对于涉及递归的算法，分析起来可能有一些困难）：第一步，首先，假设算法的问题规模为n，以程序的每一条语句为单位，为不同类型的语句设定一个耗时量，考虑每条语句的运行次数，最后将这些时间统计起来。如果追求精细，可以了解一下C/C++语言运行赋值语句，声明语句，运算语句的耗时（例如：`getchar()`, `printf()`, `cin`这三类输入语句其实有很大的性能差距，很多OIer为追求几十毫秒的性能，甚至会自己为程序写一个快速读入、输出函数来优化性能）。反之，如果仅仅是粗略分析一下，时间复杂度的量级，可以仅仅统计循环结构中的语句和执行次数并且不考虑不同语句的执行效率一视同仁地记为单位1即可。

第二步是将计算得到的时间函数 $T(N)$ 进一步略去其低阶项和常数，仅考虑时间增长趋势的一个上界。例如：$T(n) = 2n^2 + 2n + 1$ 这是我们可以直接取为 $O(n^2)$ 。（$O(f(x))$ 是同阶无穷大的意思）

### 算法的空间性能分析

这部分由于书上介绍的比较简单，我也不想再过多介绍。一般，只要熟悉了程序中各个变量的生命（什么时候获取空间，什么时候释放空间），就足够分析清楚算法的空间复杂度了。

## 数据结构+算法=程序

计算机软件的最终成果都是以程序的形式表现的，数据结构与算法分析的目的是设计出好的程序。著名的计算机科学家沃思（N.Wirth）专门出版了《数据结构+算法=程序》一书，并在其中指出 **程序是由算法和数据结构组成的，程式设计的本质是要对处理的问题选择好的数据结构，并同时在此结构上施加一种好的算法。**

### 程序和数据结构

对于一个程序来说，数据是“原料”。一个程序所要进行的计算或处理的对象总是某些数据。将松散、无组织的数据按某种要求组成一种数据结构，对于设计一个简明、高效、可靠的程序是大有毗益的。沃思指出：程序就是在数据的某些特定的表示方法和结构的基础上对抽象算法的具体描述，所以说程序离不开数据结构。

程序是通过某中程序设计语言来描述的，程序设计语言具有实现数据结构和算法的机制，其中类型声明与对象定义用于实现数据结构，而语句实现算法，描述程序行为。

### 算法和程序

由程序设计语言描述的算法就是计算机程序。对于一个求解问题而言，算法就是解题的方法，没有算法，程序就成了无根之木，无源之水。有了算法，将它表示成程序是不苦难的。算法是程序的“灵魂”，算法在整个计算机科学中的地位都是极其重要的。

### 算法和数据结构

求解的问题可以通过抽象的数据类型来描述，它由数据的逻辑结构和抽象运算两部分组成。一种数据的逻辑结构可以映射成多种存储结构，抽象运算在不同的存储结构上实现可以应对多种算法，在同一中存储结构上实现也可能有多种算法，通过算法的时间复杂度和空间复杂度等分析可以得到好的算法。

![20211016](https://picofwwzy-1307689287.cos.ap-shanghai.myqcloud.com/uPic/20211016.png)

注意，不能离开了数据结构去抽象地考虑算法，也不能脱离算法去孤立地讨论数据结构，只能从数据结构与算法相统一的角度去认识程序。

数据结构会影响算法的好坏，因此大家在选择存储结构也要考虑其对算法的影响。存储结构对算法的影响主要在以下两个方面：

#### 1.存储结构的存储能力

如果存储结构的存储能力强、存储的信息多，算法将会比较好设计。反之，对于比较简单的存储结构可能要设计一套比较复杂的算法。在这一点上经常体现时间与空间的矛盾，往往存储能力是与所使用的空间大小是成正比的。

#### 2.存储结构与所选择的算法相适应

存储结构是实现算法的基础，也会影响算法的设计，其选择要充分考虑算法的各种操作，应与算法的操作相适应。

所以说设计算法与选择合适的数据结构是程序设计中相辅相成的两个方面，缺一不可。数据结构的选择一直是程序设计中的重点和难点，正确地应用数据结构往往能带来意想不到的效果。反之，如果忽视了数据结构中的重要性，对某些问题有时就得不到满意的解答。

算法通常是决定程序效率的关键，但一切算法终究都要在相应的数据结构上实现，许多算法的精髓就是在于选择了合适的数据结构作为基础。在程序设计中，不仅要注重算法设计，也要正确选择数据结构，这样往往能事半功倍。

## 递归

### 什么是递归？

在定义一个函数，出现直接或者间接调用函数本身。若在函数体中直接调用自身，称为直接递归。若过程或函数p调用过程，或者函数q在q中又调用p（简单来看就是：p->q->p），称为间接递归。

递归不仅是数学中的一个重要概念，也是计算机技术中的重要概念。在计算机技术汇中与递归有关的概念还有递归数列、递归算法、递归程序和递归方法等。

1. 递归数列指的是由递归关系所确定的数列
2. 递归过程指的是直接或者间接调用自身的过程
3. 递归算法指的是包含递归过程的算法
4. 递归程序指的是直接或者间接调用自身的程序
5. 递归方法指的是一种在有限步骤内根据特定的法则或公式对一个或者多个前面的元素进行运算，以确定一系列元素（如数或者函数）的方法。

Example：求自然数 n 的阶乘 	(factorial)

```
int fact () {
	return n > 0 ? fact(n-1)*n : 1;
}
```

可知函数的运行例程中，有如下的调用栈：

`fact(5) -> return fact(4)*5 -> return fact(3)*4 -> return fact(3)*4 -> ... return fact(0)*1`

### Questions list

什么是函数？
: 模块化抽象化的计算过程

编译器是如何处理递归的函数调用呢？ 
: 同一个代码段，不同的输入数据

那么程序运行时不同的数据（如：`fact(5)`, `fact(4)`, ... , `fact(0)`）是如何存储和使用的呢？ 
: 系统使用程序栈中的栈帧来保存被调用的数据。（堆栈中的一个元素叫做栈帧，不要求类型相同，相当于是内存上一段接着一段连续的内存区）

`fact(0)*1 -> fact(1)::return 1*1 -> fact(2)::return 1*2 -> ... -> fact(5)::return 24*5`

递归的好处？
: 可以用比较精简的代码实现丰富的操作，极大拓宽了算法能解决的问题（更加有效），虽然但是也降低了可读性

开发效率与运行效率对比：
对于开发效率来说，递归大于循环，写程序比较方便
对于运行效率来说，循环大于递归，性能更高一些

如何提升递归的效率？ 
: 剪枝（规避不必要的调用） 或者 记忆化递归（不重复计算已经计算过结果）

### Exercise： Tower of Hanoi

有三根柱子，一摞下小下大的盘子，要将该摞盘子移动到另一根柱子上

思路：要移动 n 个盘子
1. 可以先将 n-1 个盘子移动到中转柱上
2. 这是可以直接将第 n 个盘子移动到目标柱上
3. 最后将中间的 n-1 个盘子移动到目标柱上

```cpp
void Hanoi_Tower (int hight, int u, int trans, int v)  {
	if (hight == 1) 
		move (u, v); 
    // 输出一下移动方法就可以，我开始还在想要怎么把这个塔存储起来
	else {
		Hanoi_Tower (hight - 1, u, v, trans);
		move (u, v);
		Hanoi_Tower (hight - 1, trans, u, v)；
	}
}
```

### 递归算法的非递归化

对于尾递归算法可以用循环转换为等价的非递归算法
: **尾递归** 算法是指这样一类递归函数，其递归调用语句是函数中的最后一条执行语句。

对于非尾递归算法，可以用栈模拟的方法，来实现栈结构的调用和回溯。

#todo-栈模拟程序
```cpp
typedef struct {
	int n;
	char src, des, trans;
	bool flag;
}ElemType;

void Hanoi_Tower (ElemType &st, int hight, int u, int trans, int v) {

	while (!stackEmpty()) {
		e = st.top();
		st.
	}
}
```

## 树和二叉树

### 树的表示

1. 维恩图表示法
2. 凹入表示法

### 树的基本术语

#### 对于树的组成部分

边
: 两个节点之间存在一个有序对，成为连接两节点之间的一条边

度数
: 一个结点的子树的个数，称为该节点的度

树的度数
: 指树中各个节点的最大度数

树叶
: 没有子树的节点成为该树的树叶节点或者终端节点，其度数为0

分支节点
: 度数不为0的非终端节点（非树叶节点）

路径长度
: 路径通过的结点数-1 （根节点路径长度为0）

父节点、子节点和兄弟节点
	1. 树中一个节点的后继节点称为该节点的子节点
	2. 树中一个节点的前驱节点称为该节点的子节点

节点的层数
	- 根节点层数为1 （也说根节点层数为0）
	- 其他任何节点的层数为父节点的层数+1

树的高度
：树中各节点的最大层数

#### 一些特别的树

n次树
: 指度数为 n 的树，其各个节点至多有 n 个分支

有序树
: 在树中如果各个子树的相对次序是确定的，则成该树为有向有序树，简称有序树

完全树
: 指树叶节点在同一层，且恰好将树的该层充满的树

n次正则树
: 指每一个分支节点的度数为 n 的树

二叉树
: 一般指二次有序树，不一定为完全树，也不一定为正则树。不能说是树（有序树与树的概念之间没有包含关系）的特殊形态，只能说是树在加上有序的约束之后得到的一类特殊的有序树。

#### 树的性质

## 二叉树

### 关于二叉树的基本术语

满二叉树
: 如果一棵二叉树的任何节点，要么是叶子节点，要么有两颗非空的子树

完美二叉树
: 所有的叶子节点都在同一层的满二叉树

完全二叉树
: 所有叶子节点都在同一层，并且尽可能靠左。由一列数组直接生成的二叉树，满足 节点 i 的左子节点的指标为 `(i<<1)`，右子节点的指标为 `(i<<1)+1` （注意：根节点的指标从 1 开始)

# 附录

- [本书提到的概念](./概念集.md)
