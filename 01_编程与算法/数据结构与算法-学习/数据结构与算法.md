# 数据结构与算法

## 什么是数据结构？

要理解数据结构，首先从目的、功能的角度看。计算机要解决一个具体的问题，大致需要经过如下几个步骤：

1. 分析问题，确定数据模型
2. 设计相应的算法
3. 编写程序，运行并调试，直至得到正确的结果

这里提出了一个概念叫做 **数据模型** 。作为一个数学系应用数学专业的学生，我一个想到的是既然都叫做模型，那么数据模型和数学模型有什么异同呢？

首先一个最令人困惑的问题是数学、数据，这两个词到底有什么区别？（我最近比较喜欢用这种分析语义语词的方式理解问题）。参考百度上的解释：

- **数学** 作为学科，其目的在于研究数量、结构、变化、空间以及信息等概念。作为思维方法，是人类对事物的抽象结构与模式进行严格描述的一种通用手段。
- *与其说是通用手段，不如说每每当人类将问题给抽象化，特征化，便无可避免地使用（亦或是发明）某种“数学”*。
- **数据** 作为类，是指对客观事件进行记录并可以鉴别的符号，是对客观事物的逻辑归纳。数据经过加工和处理成为可被解读的信息。

至此，我觉得可以给出一个更加清晰的定义：数学是对世界的抽象化，而数据是对世界的符号化。数学抽象的结果最终表现一整套的数学理论（由公理，命题和论证组成），而数据符号化的结构最终表现为符号以及符号之间关系构成的集合与现实世界的对应关系（如计算机中的二进制mp3文件和播放出来的声音之间的关系）。

在这本数据结构的教材中，数据的定义更加切实，作者非常直接了当地指出：“**数据是描述客观事物的数和字符组成的集合**，是所有能够被输入到计算机中，且能够被计算机处理的符号的集合”。

从数据作为集合的概念延展开来，我们不难理解数据集合中的元素称为 **数据项**，数据集合的子集称为 **数据对象**，数据集合上的关系称为 **数据结构** 。

其中，数据项是保持数据所代表含义的独立性的最小单位，例如一名学生的学号为20192025xxx，不能再进一步拆分处理，否则便会丧失其具体的含义。

数据对象是保持性质相同的数据元素共同构成的集合。所谓“性质”，一般指的是这个集合中的每个元素对应地描述了一类性质相同对象，而非是在说数据元素本身有什么性质。例如ASCII编码构成的数据对象共同描述了计算机可以表示的符号和形状。

数据结构是数据集合上的关系。这样的关系往往是人们通过分析现实问题认为建构出来的，与数据本身取值多少可能没有必然联系。

最后一点，是数据结构的层次问题。通常来讲，数据结构包含着两方面的层次，分别是逻辑结构和存储结构，以刻画数据含义之间的逻辑关系（与具体的问题有关）和数据在计算机电子构件中的存储表示及其关系。任何对数据结构的改动，从某种意义上讲，都可以被称之为数据的 **运算**，由于数据结构的不同层次，运算既可以是更改数据在计算机中的存储关系的各种操作，也可以是对现实事物之间关系的刻画。

### 逻辑结构及其表示

在现实世界中数据元素之间关系是多种多样的，但在数据结构中主要讨论数据之间的相邻关系或者邻接关系。

#### 逻辑结构的分类

按类型划分，我们对数据的逻辑结构作归纳，无外乎如下几类：

1.**集合**
: 集合是指数据元素之间除了属于同一个集合的关系之外，再没有其他关系的集合。

2.**线性结构**
: 线性结构(linear structure)是指该结构中的数据元素之间存在一对一的关系。其特点是除了唯二两个起点和终点仅有一个唯一的前驱（或后继）以外，其余的每一个数据元素均各有一个前驱元素和后继元素。

3.**树形结构**
: 树形结构是指该结构中的数据元素存在一对多的关系，除了为唯一一个顶点没有前驱元素，以及树叶节点没有后继元素外，其余每一d个数据元素均有一个前驱元素以及至少一个后继元素。

4.**图形结构** 
: 图形结构是指该结构中数据元素之间存在多对多的关系，每个数据元素的前驱和后继的个数可以使任意的。

#### 逻辑结构的表示

（1） 图表表示
: 图表表示就是直接按顺序编号，把数据项在一张表格中列出来。例如：

| 学号 | 姓名 | 性别 |
|:----:|:----:|:----:|
|   1  | 张斌 |  男  |
|   8  | 刘丽 |  女  |
|  34  | 李英 |  女  |
|  20  | 陈华 |  男  |

（2） 集合（二元组）表示
: 我们称一个元素集合和一个关系二元关系集合构成一个逻辑结构的二元组，一个二元组的表示如下：

$B=(D,R)$

其中，$D$ 为数据项构成的集合，$R$ 为$D$ 上的二元关系集合。

$D=\{d_i | 1 \le i \le n, n \ge 0 \}$ 

$R = \{r_j | 1 \le j \le m, m \ge 0 \}$ 

$d_i$ 表示集合 $D$ 中的第 i 个元素，$n$ 为$D$ 中元素的个数。$r_i$ 表示集合 $D$ 中的第i种关系，$m$ 为$R$ 中的关系个数。对于关系集合$r_i$ 来说，集合中的每一个元素为 $<x,y>, x,y \in D$ 代表元素x
与元素y之间存在相邻关系（<前驱，后继>）。

（3）图形表示
: 简单地用一个圆圈+数字来表示节点，用箭头来表示相邻关系。可以做出如下的图形

![20211003](https://picofwwzy-1307689287.cos.ap-shanghai.myqcloud.com/uPic/20211003.png)

其二元组表示为：
$$
\begin{aligned}
& B = \{ 25, 36, 48, 57, 64, 82, 75 \} \\ 
& D = \{ r_1, r_2 \} \\
& r_1 = \{ <48,25>, <25,36>, <48,64>, <64,57>, <64,82>, <82,75> \}\\
& r_2 = \{ <25,36>, <36,48>, <48,57>, <57,64>, <64,75>, <74,82> \} 
\end{aligned}
$$
### 存储结构

在实际应用中，数据结构的存储方法是灵活多样的，归纳起来，数据结构中有以下4中常用的存储结构类型。

#### 顺序存储结构

顺序存储结构（sequential storage structure）是采用一组连续的存储单元存放所有的数据元素。数据元素不仅在逻辑结构中相邻，由于顺序存储的方式，其在存储其中的存储位置也相邻。

*优点*：存储效率高，可以实现对元素的随机存取。

*缺点*：不便于数据修改，对元素的插入和删除操作可能需要移动一系列的元素。

#### 链式存储结构

在链式存储结构（linked storge structure）中，每个逻辑元素单独分配一个内存节点，所有节点的内存地址是间断的，通过每个节点的附加指针连接起来，最终将所有的逻辑元素链接起来。

*优点* ：方便数据修改（只需要修改前后节点的指针）。

*缺点* ：不能对存储节点进行随机存取，存储效率相比顺序存储减半。

#### 索引存储结构

索引存储结构（indexed storge structure）是指在存储元素信息的同时还建立附加的索引表。索引表中每一项称为索引项，其一般形式为“关键字，地址”，关键词用于标识某个特定元素，地址用于记录该元素的内存地址。通常为了便于查询，索引表中所有索引项是按关键字有序排列的。

*优点* ：查找效率高

*缺点* ：建立了索引表，增加了空间开销

#### 哈系（或散列）存储结构

哈系存储结构（hashed storge structure）的基本思想是根据元素的关键字通过哈系函数直接计算出一个值，并将这个值作为该元素的存储地址。

*优点* ：查找速度快，能够对元素进行快速的查找和插入

*缺点* ：只存储元素的数据，不存储元素之间的逻辑关系（没有简便的方法以任何一种顺序遍历表中的数据项)；基于数组的哈系表，不便于扩展，在数组基本被填满后性能下降得非常严重

### 数据运算

数据运算是指对数据实施的操作。每种数据结构都有一组相应的运算，最常用的运算有检索、插入、删除、更新和排序等。数据运算最终需要在对应的存储结构上以特定的算法实现。

值得注意的一点是，运算的定义是基于逻辑结构层面，出于人们对解决现实问题的需要抽象出来的特定功能或者方法。运算的实现是基于存储结构层面，是依靠算法对具体的存储单元进行编程操作实现的。

运算之所有被分为这两种层面，我想，一方面虽然按书上说的“体现了软件工程的思想”，另一方面也导致了程序用户和程序员之间的分裂，使得一般的用户无法接触到程序内部的细节，只能被动地使用程序定义好的功能，而不能主动地凭自己的意见作修改。如果有那么一天，现实计算机的存储方式能够更加适合人类看待问题的方式，在迎合逻辑结构的同时，不再需要结构复杂的算法（才能保证稳定和效率）就能解决所有的问题，那么这里运算的两种层次的分裂将为被弥合。我想，届时人类可以利用计算机做到更多有趣的事情？

### 数据类型和抽象数据类型

这一部分还是自己在实践中掌握比较好

## 算法及其描述

### 什么是算法？

算法（algorithm）是对特定问题求解步骤的一种描述，它是指令有限的序列。其中每条指令代表计算机的一个或者多个操作。

一个算法应该具有一下5中重要的特性：

1. 有穷性：一个算法必须在有限步骤内完成。
2. 确定性：对于每种情况执行的操作的都是确定的，即使说相同的输入总应该有同样的输出。
3. 可行性：算法可以通过计算机基本操作的有限次组合来完成，否则计算机无法实现。
4. 有输入：作为算法加工对象的量值，通常体现为一组变量，这是不可或缺的（可能程序员可以不要求任何变量的输入，但一个算法总是有特定加工处理的对象，比如void函数体内部的变量）。
5. 有输出：作为算法对信息进行处理加工后的结构，一个算法有一个或者多个输出。

*算法输入和输出的特定关系构成了算法的功能*.

### 算法设计的目标

1. 正确性：算法能够正确地执行预先设定的功能和性能要求。这是最最基本的要求。
2. 可实用性：要求程序能够方便地被使用，也称为用户友好性。
3. 可读性：算法应该易于理解，这要求的算法的逻辑必须是清晰的、简单的和结构化的。
4. 健壮性：要求算法具有较好的容错性，即提供异常处理。
5. 高性能和低存储需求：要求尽可能节省算法时间和空间的开销。

### 算法描述

简单介绍一下应该是有5种方法，可以用来描述一个确定的算法：

1. 自然语言：可以直接以通俗形象的语言来描述算法，尽管会丧失一定的严谨准确性。
2. 流程图：适合顺序、循环结构的算法，不是具有递归结构的算法
3. 伪代码：结合自然语言和程序语言，比较容易理解。
4. 程序语言：最直接的描述方法
5. 调用流程：以程序中函数为单位来描述算法的方法，适合一些复杂工程，也可以用来分析递归算法的成效。

## 算法分析

### 什么是算法分析？

算法分析就是分析算法占用计算机资源的多少。而计算机资源主要是CPU时间和内存空间，因此算法分析又分为时间性能分析和空间性能分析。

### 算法时间性能分析

一般来说，有两种衡量算法时间性能的方法，即事后统计法和事前估计法。（按字面意思就很好理解）

而在设计算法的过程最常用的是事前估计的方法，一般我们称之为算法的时间复杂度分析。

算法的时间复杂度分析一般分为两步（熟练的Oier大概可以之间看出来，
不过对于涉及递归的算法，分析起来可能有一些困难）：第一步，首先，假设算法的问题规模为n，以程序的每一条语句为单位，为不同类型的语句设定一个耗时量，考虑每条语句的运行次数，最后将这些时间统计起来。如果追求精细，可以了解一下C/C++语言运行赋值语句，声明语句，运算语句的耗时（例如：`getchar()`, `printf()`, `cin`这三类输入语句其实有很大的性能差距，很多OIer为追求几十毫秒的性能，甚至会自己为程序写一个快速读入、输出函数来优化性能）。反之，如果仅仅是粗略分析一下，时间复杂度的量级，可以仅仅统计循环结构中的语句和执行次数并且不考虑不同语句的执行效率一视同仁地记为单位1即可。

第二步是将计算得到的时间函数 $T(N)$ 进一步略去其低阶项和常数，仅考虑时间增长趋势的一个上界。例如：$T(n) = 2n^2 + 2n + 1$ 这是我们可以直接取为 $O(n^2)$ 。（$O(f(x))$ 是同阶无穷大的意思）

### 算法的空间性能分析

这部分由于书上介绍的比较简单，我也不想再过多介绍。一般，只要熟悉了程序中各个变量的生命（什么时候获取空间，什么时候释放空间），就足够分析清楚算法的空间复杂度了。


## 数据结构+算法=程序


# 附录

- [本书提到的概念](./概念集.md)
